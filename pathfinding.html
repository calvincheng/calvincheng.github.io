<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Calvin Cheng</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" href="assets/svg/logo.svg">
    <link rel="stylesheet" href="style.css">
    <!-- Need to redownload fonts? Check -->
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@400;500;600&family=Nunito+Sans:wght@400;600;700&display=fallback" rel="stylesheet">
    <link rel="stylesheet" href="assets/styles/default.css">
    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <div class="nav-wrapper">
    <nav>
      <div class="logo">
        <a href="/">
          <!--<img src="assets/svg/logo.svg" alt="" height="50px">-->
          <svg class="logo-svg" height="50" width="50">
            <path d="M-401.27-840.63a4.22,4.22,0,0,0-.91-1,4.54,4.54,0,0,0-1.24-.69,4.35,4.35,0,0,0-1.44-.24,4.89,4.89,0,0,0-2.35.53,4.44,4.44,0,0,0-1.56,1.42,6.23,6.23,0,0,0-.87,2,10.08,10.08,0,0,0-.27,2.35,9.53,9.53,0,0,0,.27,2.27,6.1,6.1,0,0,0,.87,2,4.51,4.51,0,0,0,1.56,1.41,4.89,4.89,0,0,0,2.35.53,3.77,3.77,0,0,0,2.92-1.14,5.17,5.17,0,0,0,1.29-3h4a9.13,9.13,0,0,1-.81,3.13,7.28,7.28,0,0,1-1.72,2.38,7.15,7.15,0,0,1-2.49,1.5,9.13,9.13,0,0,1-3.15.52,9.4,9.4,0,0,1-3.84-.74,8.08,8.08,0,0,1-2.88-2,9.08,9.08,0,0,1-1.8-3,11.29,11.29,0,0,1-.62-3.77,11.62,11.62,0,0,1,.62-3.84,9.26,9.26,0,0,1,1.8-3.1,8.18,8.18,0,0,1,2.88-2.07,9.4,9.4,0,0,1,3.84-.75,9.51,9.51,0,0,1,2.9.44,8,8,0,0,1,2.45,1.28,7.09,7.09,0,0,1,1.78,2.09,7.29,7.29,0,0,1,.88,2.84h-3.95A3.41,3.41,0,0,0-401.27-840.63Z" transform="translate(414 846)"/>
            <path d="M-379.41-845.56v15.07h9.06v3.42h-13.14v-18.49Z" transform="translate(414 846)"/>
            <path d="M-407.73-796l-6-18.49h4.19l4.14,13h.05l4.19-13h4.22L-403.12-796Z" transform="translate(414 846)"/>
            <path d="M-382.32-814.49l7.75,12.4h.06v-12.4h3.82V-796h-4.08l-7.73-12.38h-.06V-796h-3.82v-18.49Z" transform="translate(414 846)"/>
            <path d="M-376.91-801.5l-32.69-5.74,5.77-32.51,32.68,5.73ZM-408.52-808l30.85,5.42,5.44-30.7-30.85-5.41Z" transform="translate(414 846)"/>
          </svg>
        </a>
      </div>
      <ul class="nav-links">
        <li>
          <a href="about">(about)</a>
        </li>
      </ul>
    </nav>
  </div>
  <body>
    <div class="article-wrapper fadein">
      <div class="article-heading">
        <h1>Pathfinding Visualiser</h1>
        <h2>Visualising pathfinding algorithms within the terminal</h2>
      </div>
      <img class="article-cover" src="assets/img/pathfind_cover.png">
      <div class="chapter-list-anchor">
        <div class="chapter-list-wrapper">
          <ul>
            <li class="chapter">
              <span class="chapter-current" onclick="scrollToId( 'subheading-1' )">
                Board representation
              </span>
            </li>
            <li class="chapter"> 
              <span onclick="scrollToId( 'subheading-2' )">
                Pathfinding algorithms
              </span>
            </li>
            <li class="chapter"> 
              <span onclick="scrollToId( 'subheading-3' )">
                Modular menu design
              </span>
            </li>
            <li class="chapter"> 
              <span onclick="scrollToId( 'subheading-4' )">
                Putting it all together with Curses
              </span>
            </li>
          </ul>
        </div>
      </div>
      <div class="article-info-wrapper">
        <div class="article-info">
          <h5>SKILLS</h5>
          <ul>
            <li>
              <span class="type-significant">Python</span>
              <span class="type-significant">Curses</span>
            </li>
          </ul>
        </div>
        <div class="article-info">
          <h5>TOPICS</h5>
          <ul>
            <li>
              <span class="type-significant">Graph Search</span>
              <span class="type-significant">Dijkstra</span>
              <span class="type-significant">A*</span>
            </li>
          </ul>
        </div>
      </div>
      <div id="article-start" class="article-body">
        <!--
        <h3 style="margin: 0"></h3> Hacky fix for headingHeights to work -->
        <p>
          <em style="color: #888">This post is still a work in progress.</em>
        </p>
        <p>
          After reading up on Algorithms and Data Structures, a natural way to
          progress was to consolidate what I've learnt through application. As
          my weakest area was, by far, graph traversals and searches, I created
          a small console application visualising several popular pathfinding
          algorithms to better understand their nuances and inner-workings. 
        </p>
        <h3 id="subheading-1">Board representation</h3>
        <p>
          A generic grid can be considered as a specific type of graph, where
          each node is connected to its four orthogonal neighbours and the
          distance to each neighbour are identical. Although graphs are
          typically represented by an edge list or an adjacency matrix, the more
          intuitive data structure to use in this case would be would be a 2D
          array (i.e. a matrix), where each element is representative of a
          vertex within the graph. Therefore, we take an object-oriented
          approach and define a <code class="inline">Board</code> object of
          width <code class="inline">w</code> and height <code
            class="inline">h</code> initialised via </p>
        <pre><code class="python"><!--
        -->class Board:
<!--    -->    def __init__(self, w, h):
<!--    -->        self.w = w
<!--    -->        self.h = h
<!--    -->        self.board = [[0 for _ in range(w)] for _ in range(h)]<!--
     --></code></pre>
        <p>
          where <code class="inline">0</code> represents an empty node, and
          <code class="inline">1</code> a wall node.
        </p>
        <figure>
          <img src="assets/img/default.png" alt="description">
          <figcaption>The board matrix and its visual representation.</figcaption>
        </figure>
        <p>
          Like most graph representations, it would be nice to have a convinent
          way of getting all the neighbours of a specific node. This can be done
          by writing a method that takes a node's four neighbours, making sure
          that they're not a wall node, and that they're actually within the
          board.
        </p>
        <pre><code class="python"><!--
        -->def getNeighbours(self, node):
<!--    -->    '''Gets neighbouring free nodes within the board
<!--    -->    node: (x, y) tuple
<!--    -->    '''
<!--    -->    x, y = node
<!--    -->    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
<!--    -->    nbrs = []
<!--    -->    for dx, dy in dirs:
<!--    -->        if self.inBoard(x+dx, y+dy) and self.board[y+dy][x+dx] != 1:
<!--    -->            nbrs.append((x+dx, y+dy))
<!--    -->    return nbrs
<!--    -->
<!--    -->def inBoard(self, x, y):
<!--    -->    '''Helper function that returns TRUE if (x, y) is valid.'''
<!--    -->    return (0 <= x < self.w) and (0 <= y < self.l)<!--
                --></code></pre>
        <h3 id="subheading-2">Pathfinding algorithms</h3>
        <p>
          One of the simplest pathfinding methods involves breadth-first search â€“
          from a starting node, we explore its neighbours, and then its
          neighbours' neighbours, and so on until the goal is discovered.
        </p>
        <figure> 
          <div style="width:85%" class="figure-wrapper">
            <img src="assets/img/bfs.png" alt="breadth first search">
            <figcaption>Breadth first search running on a grid.</figcaption>
          </div>
        </figure>
        <p>
          However, this is a naive search; the algorithm has no concept of the
          costs of travelling from node to node, nor does it prioritise which
          neighbours to explore. Imagine a situation where you're finding the
          best way of driving from point A to point B. Naturally, we'd look for
          a road that's convenient and fast to drive on (i.e. a motorway) that
          also heads in the direction of point B. We should expect an efficient
          pathfinder to follow this intuition, prioritising low-cost nodes that
          are close to the goal. This is where Dijkstra's algorithm and A* come
          in.
        </p>
        <p>
          Typically, a breadth-first search is implemented by placing the
          neighbours of visited nodes inside a queue. The first-in-first-out
          (FIFO) property of queues allows the nodes closest to the start to be
          explored first. Dijkstra's algorithm adds upon this by introducing the
          concept of priority for each element within the queue. In this new
          structure, aptly named as a priority queue, neighbours which are less
          costly are prioritised to be visited first. The priority queue
          therefore gives Dijkstra's algorithm a dynamic advantage over
          breadth-first search as it is able to reprioritise which neighbours to
          visit as the board is explored.
        </p>
        <figure>
          <div style="width:85%" class="figure-wrapper">
            <video autoplay loop muted playsinline>
              <source src="assets/mov/dijkstra.mp4" type="video/mp4" />
            </video>
            <figcaption>Dijkstra's algorithm.</figcaption>
          </div>
        </figure>
        <p>
          In this case, as the cost between each node is uniform, there is
          no discernable difference between a breadth-first search and
          Djikstra's algorithm.
        </p>
        <p>
          With the costs acknowledged, we can do even better by considering
          the distance of each node to the goal. In other words, the algorithm
          is encouraged to search nodes which are closer to the goal first. This
          is achieved with a heuristic, calculated as the distance (calculated
          typically as the Manhattan or Euclidean distance) from the node to the
          goal. Incorporating the heuristic into the search leads us to the A*
          search algorithm.
        </p>
        <figure>
          <div style="width:85%" class="figure-wrapper">
            <video autoplay loop muted playsinline>
              <source src="assets/mov/astar-euclidean.mp4" type="video/mp4" />
            </video>
            <figcaption>A* search using Euclidean distance as its heuristic.</figcaption>
          </div>
        </figure>
        <p>
          The A* search is actually the "sweet spot" when it comes to
          pathfinding, balancing both costs and heuristics to find an optimal
          path without visiting more nodes than it needs to. If Dijkstra's
          algorithm is the one extreme which prioritises exploration
          based only on cost, best-first or greedy search is the other extreme where
          it only priotises heuristic.
        </p>
        <p>
          To those intersted in implementing these algorithms themselves, Amit 
          Patel (also known as RedBlobGames) has written <a class="article-link" 
          href="https://www.redblobgames.com/pathfinding/a-star/implementation.html">
          an excellent article</a> on pathfinding algorithms. I would highly
          recommend anyone interested in implementing them themselves to give 
          it a read.
        </p>
        <figure>
          <div style="width:85%" class="figure-wrapper">
            <video autoplay loop muted playsinline>
              <source src="assets/mov/bestfirst-manhattan.mp4" type="video/mp4" />
            </video>
            <figcaption>Greedy search using Manhattan distance as its heuristic.</figcaption>
          </div>
        </figure>
        <p>
          Notice how it immediately tries to get as close to the goal as
          possible, being forced to divert only when it reaches the wall,
          ultimately resulting in a non-optimal path.
        </p>
        <p>
          Lastly, the application also supports bidirectional search to try to
          increase speeds further, although optimality is not guaranteed.
        </p>
        <figure>
          <div style="width:85%" class="figure-wrapper">
            <video autoplay loop muted playsinline>
              <source src="assets/mov/dijkstra-bd.mp4" type="video/mp4" />
            </video>
            <figcaption>Bidirectional Dijkstra's search.</figcaption>
          </div>
        </figure>
        <h3 id="subheading-3">Modular menu design</h3>
        <p>
        <h3 id="subheading-4">Putting it all together with Curses</h3>
        <p>
          The code for this project can be <a class="article-link"
            href="https://www.github.com/calvincheng/Pathfinding-Visualiser">found
            on Github</a>.
        </p>
      </div>
    </div>
    <script src="script.js"></script>
  </body>
</html>
