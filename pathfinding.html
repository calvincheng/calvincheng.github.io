<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Calvin Cheng</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" href="assets/svg/logo.svg">
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@400;500;600&family=Nunito+Sans:wght@400;600;700&display=fallback" rel="stylesheet">
    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="assets/styles/default.css">
    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <div class="nav-wrapper">
    <nav>
      <div class="logo">
        <a href="/">
          <!--<img src="assets/svg/logo.svg" alt="" height="50px">-->
          <svg class="logo-svg" height="50" width="50">
            <path d="M-401.27-840.63a4.22,4.22,0,0,0-.91-1,4.54,4.54,0,0,0-1.24-.69,4.35,4.35,0,0,0-1.44-.24,4.89,4.89,0,0,0-2.35.53,4.44,4.44,0,0,0-1.56,1.42,6.23,6.23,0,0,0-.87,2,10.08,10.08,0,0,0-.27,2.35,9.53,9.53,0,0,0,.27,2.27,6.1,6.1,0,0,0,.87,2,4.51,4.51,0,0,0,1.56,1.41,4.89,4.89,0,0,0,2.35.53,3.77,3.77,0,0,0,2.92-1.14,5.17,5.17,0,0,0,1.29-3h4a9.13,9.13,0,0,1-.81,3.13,7.28,7.28,0,0,1-1.72,2.38,7.15,7.15,0,0,1-2.49,1.5,9.13,9.13,0,0,1-3.15.52,9.4,9.4,0,0,1-3.84-.74,8.08,8.08,0,0,1-2.88-2,9.08,9.08,0,0,1-1.8-3,11.29,11.29,0,0,1-.62-3.77,11.62,11.62,0,0,1,.62-3.84,9.26,9.26,0,0,1,1.8-3.1,8.18,8.18,0,0,1,2.88-2.07,9.4,9.4,0,0,1,3.84-.75,9.51,9.51,0,0,1,2.9.44,8,8,0,0,1,2.45,1.28,7.09,7.09,0,0,1,1.78,2.09,7.29,7.29,0,0,1,.88,2.84h-3.95A3.41,3.41,0,0,0-401.27-840.63Z" transform="translate(414 846)"/>
            <path d="M-379.41-845.56v15.07h9.06v3.42h-13.14v-18.49Z" transform="translate(414 846)"/>
            <path d="M-407.73-796l-6-18.49h4.19l4.14,13h.05l4.19-13h4.22L-403.12-796Z" transform="translate(414 846)"/>
            <path d="M-382.32-814.49l7.75,12.4h.06v-12.4h3.82V-796h-4.08l-7.73-12.38h-.06V-796h-3.82v-18.49Z" transform="translate(414 846)"/>
            <path d="M-376.91-801.5l-32.69-5.74,5.77-32.51,32.68,5.73ZM-408.52-808l30.85,5.42,5.44-30.7-30.85-5.41Z" transform="translate(414 846)"/>
          </svg>
        </a>
      </div>
      <ul class="nav-links">
        <li>
          <a href="about">(about)</a>
        </li>
      </ul>
    </nav>
  </div>
  <body>
    <div class="article-wrapper fadein">
      <div class="article-heading">
        <h1>Pathfinding Visualiser</h1>
        <h2>Visualising pathfinding algorithms within the terminal</h2>
      </div>
      <img class="article-cover" src="assets/img/pathfind_cover.png">
      <div class="chapter-list-anchor">
        <div class="chapter-list-wrapper">
          <ul>
            <li class="chapter">
              <span class="chapter-current" onclick="scrollToId( 'subheading-1' )">
                Pathfinding algorithms
              </span>
            </li>
            <li class="chapter"> 
              <span onclick="scrollToId( 'subheading-2' )">
                The board
              </span>
            </li>
            <li class="chapter"> 
              <span onclick="scrollToId( 'subheading-3' )">
                Maze generation
              </span>
            </li>
            <li class="chapter"> 
              <span onclick="scrollToId( 'subheading-4' )">
                Menu design
              </span>
            </li>
          </ul>
        </div>
      </div>
      <div class="article-info-wrapper">
        <div class="article-info">
          <h5>SKILLS</h5>
          <ul>
            <li>
              <span class="type-significant">Python</span>
              <span class="type-significant">Curses</span>
            </li>
          </ul>
        </div>
        <div class="article-info">
          <h5>TOPICS</h5>
          <ul>
            <li>
              <span class="type-significant">Graph Search</span>
              <span class="type-significant">Dijkstra</span>
              <span class="type-significant">A*</span>
            </li>
          </ul>
        </div>
      </div>
      <div id="article-start" class="article-body">
        <!--
        <h3 style="margin: 0"></h3> Hacky fix for headingHeights to work -->
        <p>
          The code for this project can be <a class="article-link"
          href="https://www.github.com/calvincheng/Pathfinding-Visualiser">found
          on Github</a>.
        </p>
        <p>
          After reading up on Algorithms and Data Structures, a natural way to
          progress was to consolidate what I've learnt through practice. As my
          weakest area was, by far, graph traversals and searches, I created a
          small console application visualising several popular pathfinding
          algorithms to better understand their features.
        </p>
        <h3 id="subheading-1">Pathfinding algorithms</h3>
        <p>
          Several pathfinding algorithms are implemented within the application.
          One of the simplest methods involves breadth-first search – from a
          starting node, we explore its neighbours, and then its neighbours'
          neighbours, and so on until the goal is discovered.
        </p>
        <p>
          However, this is a naive search; the algorithm has no concept of the
          costs of travelling from node to node, nor does it prioritise which
          neighbours to explore. Imagine a situation where you're finding the
          best way of driving from point A to point B. Naturally, we'd look for
          a road that's convenient and fast to drive on (i.e. a motorway) that
          also heads in the direction of point B. We should expect an efficient
          pathfinder to follow this intuition, prioritising low-cost nodes that
          are close to the goal. This is where Dijkstra's algorithm and A* come
          in.
        </p>
        <p>
          Typically, a breadth-first search is implemented by placing the
          neighbours of visited nodes inside a queue. The first-in-first-out
          (FIFO) property of queues allows the nodes closest to the start to be
          explored first. Dijkstra's algorithm adds upon this by introducing the
          concept of priority for each element within the queue. In this new
          structure, aptly named as a priority queue, neighbours which are less
          costly to visit are explored first. The priority queue therefore gives
          Dijkstra's algorithm a dynamic advantage over breadth-first search as
          it is able to continuously reprioritise which neighbours to visit as
          the board is explored.
        </p>
        <figure>
          <div style="width:85%" class="figure-wrapper">
            <video autoplay loop muted>
              <source src="assets/mov/dijkstra.mp4" type="video/mp4" />
            </video>
            <figcaption>Dijkstra's algorithm.</figcaption>
          </div>
        </figure>
        <p>
          In this case, as the cost between each node is uniform, there is
          no discernable difference between a breadth-first search and
          Djikstra's algorithm. However, if weighted (higher cost) nodes are
          implemented in the future, we can expect the exploration to skirt
          around them.
        </p>
        <p>
          With costs acknowledged, we can do even better by considering the
          distance of each node to the goal as well. In other words, the
          algorithm is encouraged to first search nodes which are closer to the
          goal. This is achieved with a heuristic, calculated as the distance
          (calculated typically as the Manhattan or Euclidean distance) from the
          node to the goal. Incorporating the heuristic into the search leads us
          to the A* search algorithm.
        </p>
        <figure>
          <div style="width:85%" class="figure-wrapper">
            <video autoplay loop muted>
              <source src="assets/mov/astar-euclidean.mp4" type="video/mp4" />
            </video>
            <figcaption>A* search using Euclidean distance as its heuristic.</figcaption>
          </div>
        </figure>
        <p>
          The A* search is actually the "sweet spot" when it comes to
          pathfinding, balancing both costs and heuristics to find an optimal
          path without visiting more nodes than it needs to. If Dijkstra's
          algorithm is the one extreme which prioritises exploration
          based only on cost, best-first or greedy search is the other extreme where
          it only prioritises heuristics.
        </p>
        <figure>
          <div style="width:85%" class="figure-wrapper">
            <video autoplay loop muted>
              <source src="assets/mov/bestfirst-manhattan.mp4" type="video/mp4" />
            </video>
            <figcaption>Greedy search using Manhattan distance as its heuristic.</figcaption>
          </div>
        </figure>
        <p>
          Notice how it immediately tries to get as close to the goal as
          possible, being forced to divert only when it reaches the wall,
          ultimately resulting in a non-optimal path.
        </p>
        <p>
          Lastly, the application also supports bidirectional variants of each
          algorithm. They tend to improve search speeds, although optimality
          is not guaranteed.
        </p>
        <figure>
          <div style="width:85%" class="figure-wrapper">
            <video autoplay loop muted>
              <source src="assets/mov/dijkstra-bd.mp4" type="video/mp4" />
            </video>
            <figcaption>Bidirectional Dijkstra's search.</figcaption>
          </div>
        </figure>
        <p>
          To those intersted in implementing these algorithms themselves, I
          would highly recommend you to read Amit Patel's <a class="article-link"
          href="https://www.redblobgames.com/pathfinding/a-star/implementation.html">
          excellent tutorial</a> on pathfinding algorithms, where he provides a
        much more thorough and in-depth explanation of how they work.</p>
        <h3 id="subheading-2">The board</h3>
        <p>
          A generic grid can be considered as a specific type of graph, where
          each node is connected to its four orthogonal neighbours and the
          distance to each neighbour are identical. Although graphs are
          typically represented by an edge list or an adjacency matrix, in this
          case a 2D array is used as it is more intuitive. Each element within
          the array is being a vertex within the graph, with its state
          expressed through its value – <code class="inline">0</code> for an
          empty node, and <code class="inline">1</code> a wall node. For
          example, setting the 2D array as
        </p>
        <pre><code class="python"><!--
        -->board = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
<!--    -->         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
<!--    -->         [1, 0, 0, 0, 1, 1, 1, 1, 1, 1],
<!--    -->         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
<!--    -->         [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
<!--    -->         [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
<!--    -->         [1, 0, 0, 1, 1, 1, 0, 0, 0, 1],
<!--    -->         [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
<!--    -->         [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],
<!--    -->         [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]<!--
     --></code></pre>
        <p>
          gives the equivalent board below.
        </p>
        <figure>
          <div class="figure-wrapper" style="width:50%">
            <img src="assets/img/board-01.png" alt="board">
          </div>
        </figure>
        <p>
          The application also allows board-editing, featuring the ability to
          move start and goal nodes as well as create and destroy walls. As
          mouse support is inconsistent across different terminals,
          board-editing is performed instead via a keyboard-controlled cursor. 
        </p>
        <p>
          The user is then able to navigate using the arrow keys, and perform
          actions using the spacebar. The action is context dependent – pressing
          the spacebar as the cursor is over a wall node puts the cursor in
          the erasing state, whilst pressing the spacebar as the cursor is over
          a blank node puts it in a wall-building state.
        </p>
        <p>
          In addition to the cursor, basic movement of the start and goal nodes
          using the arrow keys is also supported. Their movements are limited to
          only free nodes, such that they cannot move through walls. When using
          the cursor, the start and goal nodes can also be instantly placed upon
          the cursor location with the 0 and 1 keys.
        </p>
        <p>
          As the board is edited, existing search visualisations automatically
          update to the new changes, adding a layer of interactivity to the
          editing process.
        </p>
        <figure>
          <div style="width:100%" class="figure-wrapper">
            <video autoplay loop muted>
              <source src="assets/mov/boardEditing2.mp4" type="video/mp4" />
            </video>
            <figcaption>Updated search visualisations during board editing.</figcaption>
          </div>
        </figure>
        <h3 id="subheading-3">Maze generation</h3>
        <p>
          Basic maze generation is also included to provide extra variety to the
          board environment. The maze is generated via a depth-first
          search strategy which tunnels passages within an board composed
          initially of only walls.
        </p>
        <figure>
          <div style="width:100%" class="figure-wrapper">
            <video autoplay loop muted>
              <source src="assets/mov/mazeGen.mp4" type="video/mp4" />
            </video>
            <figcaption>Maze generation and search.</figcaption>
          </div>
        </figure>
        <p>
          A neat feature of using depth-first search is that its recursive
          nature allows the function to be written in a surprisingly few number
          of lines.
        </p>
        <pre><code class="python"><!--
     -->def mazify(self):
<!-- -->'''Generates random maze using DFS'''
<!-- -->    self.board = [[1 for _ in range(self.w)] for _ in range(self.l)]
<!-- -->    x = random.randrange(1,self.w - 1,2)
<!-- -->    y = random.randrange(1,self.l - 1,2)
<!-- -->    self.board[y][x] = 0
<!-- -->    self.carve(x, y)
<!-- -->    
<!-- -->    # Delete walls directly above start and goal
<!-- -->    start_x, start_y = self.start
<!-- -->    goal_x, goal_y = self.goal
<!-- -->    self.board[start_y][start_x] = 0
<!-- -->    self.board[goal_y][goal_x] = 0
<!-- -->
<!-- -->def carve(self, x, y):
<!-- -->    '''Helper recursive function for DFS maze generation.
<!-- -->    "Carves" a tunnel from position (x, y).
<!-- -->    '''
<!-- -->    DIRS = [(0, -2), (2, 0), (0, 2), (-2, 0)] # N, E, S, W
<!-- -->    random.shuffle(DIRS)
<!-- -->    for dx, dy in DIRS:
<!-- -->        if self.inBoard(x+dx, y+dy) and self.board[y+dy][x+dx] == 1:
<!-- -->            # Open wall between (x, y) and (x+dx, y+dy)
<!-- -->            for i in range(min(x, x+dx), max(x, x+dx)+1):
<!-- -->                for j in range(min(y, y+dy), max(y, y+dy)+1):
<!-- -->                    self.board[j][i] = 0
<!-- -->            self.carve(x+dx, y+dy)<!--
                --></code></pre>
        <p>
          Granted, the size of the maze is limited by the maximum recursion
          depth of Python. However, as the dimensions of the board is fixed in this
          case, it's not really a problem.
        </p>
        <h3 id="subheading-4">Menu design</h3>
        <p>
          Tying everything together, a menu was created to provide easy access
          to functions as well as provide additional information if needed (such
          as instructions when editing the board, or displaying the current
          search method used). 
        </p>
        <figure>
          <!-- disgustingly hardcoded -->
          <div style="width: 150px" class="figure-wrapper">
            <video height="520px" autoplay loop muted>
              <source src="assets/mov/menu.mp4" type="video/mp4" />
            </video>
            <figcaption>Menu navigation.</figcaption>
          </div>
        </figure>
        <p>
          To keep the menu flexible such that items may be reordered and renamed
          when needed, an object-oriented approach was taken. Menu items are
            split into <code class="inline">Text</code>, <code
              class="inline">Radio</code> and <code
              class="inline">Button</code> classes, each with their own children
            to further specify their uses. The menu items are then provided to
            the primary <code class="inline">Menu</code> object as an argument
            during its construction. Overall, the menu is able to support both
            vertical and horizontal navigation.
        </p>
        <p>
          If you would like to try out the application yourself, the code for
          this project can be <a class="article-link"
          href="https://www.github.com/calvincheng/Pathfinding-Visualiser">found
          on Github</a>.
        </p>
      </div>
    </div>
    <script src="script.js"></script>
  </body>
</html>
